<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=3f5c0542c9be4dc966e56b8a237feea6d34b1845">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>A stack trace for your OS | exampleOS</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="A stack trace for your OS" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="exampleOS is an OS for reference purposes" />
<meta property="og:description" content="exampleOS is an OS for reference purposes" />
<link rel="canonical" href="http://localhost:4000/tutorials/stack_trace.html" />
<meta property="og:url" content="http://localhost:4000/tutorials/stack_trace.html" />
<meta property="og:site_name" content="exampleOS" />
<script type="application/ld+json">
{"description":"exampleOS is an OS for reference purposes","@type":"WebPage","headline":"A stack trace for your OS","url":"http://localhost:4000/tutorials/stack_trace.html","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <h1>exampleOS</h1>
        <h2>exampleOS is an OS for reference purposes</h2>

        <section id="downloads">
          
          <a href="http://github.com/Techno-coder/example_os" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1 id="a-stack-trace-for-your-os">A stack trace for your OS</h1>
<h2 id="what">What?</h2>
<p>A stack trace displays the location of every function call, 
leading up to when the stack trace itself is called. Essentially, it
tells you the path your code took.</p>

<h2 id="why">Why?</h2>
<p>A stack trace is incredibly helpful for debugging purposes as
there can be multiple paths to a function call. It is important
to determine which path caused a function call.</p>

<h2 id="where">Where?</h2>
<p>In exampleOS we automatically print a stack trace whenever the
kernel panics.</p>

<h2 id="how">How?</h2>
<p>There are two ways debuggers print a stack trace. They can either
parse the <a href="http://www.dwarfstd.org">DWARF</a> debugging format which
is produced by the compiler, or they can “walk the stack” by
following the stack base pointers. exampleOS uses the latter method
as it is far simpler and works without loading the kernel
symbols. This allows us to produce a stack trace even in the very
early stages of the kernel booting process.</p>

<h2 id="the-call-instruction">The call instruction</h2>
<p>Functions are called using the assembly call instruction:</p>
<pre><code class="language-asm">call a_function
</code></pre>
<p><code class="highlighter-rouge">a_function</code> is replaced by the address of the the function during
the linking stage. More importantly, is how the call instruction works.</p>

<p>When the processor reaches the call instruction, it saves the current
instruction pointer onto the stack. This is called a “return address”. 
This is so it knows where to continue once the called function has returned.
We use this later to print the location of the function call. When 
the called function returns, the processor examines the stack, 
pops off the return address, and jumps to the return address.</p>

<h2 id="the-frame-pointer">The frame pointer</h2>
<p>Compilers have an option to add frame pointers to every function. When
frame pointers are enabled, two important assembly instructions are
inserted at the start of every function:</p>
<pre><code class="language-asm">push rbp
mov rbp, rsp
</code></pre>
<p>This is what the stack looks like when a function is called:</p>

<p><img src="/assets/stack_trace/stack_on_call.png" style="width: 50%;" /></p>

<p>From the diagram, we can see that the return address is always above the
address stored in <code class="highlighter-rouge">rbp</code>. So, in order to find the last function’s
return address, we just minus 8 (because registers have a size of 8 bytes in 
long mode) from the address stored in <code class="highlighter-rouge">rbp</code>.</p>

<h2 id="enabling-frame-pointers">Enabling frame pointers</h2>
<p>The Rust compiler has a flag to enable frame pointers:<br />
<code class="highlighter-rouge">RUSTFLAGS=-Cforce-frame-pointers=yes</code><br />
This is referenced in the compiler source <a href="https://github.com/rust-lang/rust/blob/01a9b30c332810ad0c570e8fed91f956417dec3a/src/librustc/session/mod.rs#L667">here</a>.</p>

<p>For C and C++ compilers, the search term is <code class="highlighter-rouge">no-omit-frame-pointer</code>.</p>

<h2 id="the-code">The code</h2>
<p>You can see exampleOS’s full implementation of a stack tracer <a href="https://github.com/Techno-coder/example_os/blob/master/kernel/src/debug/stack_trace.rs">here</a>.</p>

<p>First we have to obtain the contents of the <code class="highlighter-rouge">rbp</code> register:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">base_pointer</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span><span class="p">;</span>
<span class="k">unsafe</span> <span class="p">{</span> <span class="nd">asm!</span><span class="p">(</span><span class="s">"mov rax, rbp"</span> <span class="p">:</span> <span class="s">"={rax}"</span><span class="p">(</span><span class="n">base_pointer</span><span class="p">)</span> <span class="p">:::</span> <span class="s">"intel"</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>Then, to get the return address, we increment the pointer and dereference it:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">return_address</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">*</span><span class="p">(</span><span class="n">base_pointer</span><span class="nf">.offset</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">}</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"Call site: {}"</span><span class="p">,</span> <span class="n">return_address</span><span class="p">);</span>
</code></pre></div></div>
<p>Note that in Rust, dereferencing a raw pointer is considered unsafe.</p>

<p>Finally, we need to “walk the stack” and get the return addresses of all
the previous stack frames. To do this, we set the current
base pointer to the previous stack frame’s base pointer:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">base_pointer</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="n">base_pointer</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span> <span class="p">};</span>
</code></pre></div></div>
<p>and then we just repeat all the previous code, giving us a nice loop:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">base_pointer</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span><span class="p">;</span>
<span class="k">unsafe</span> <span class="p">{</span> <span class="nd">asm!</span><span class="p">(</span><span class="s">"mov rax, rbp"</span> <span class="p">:</span> <span class="s">"={rax}"</span><span class="p">(</span><span class="n">base_pointer</span><span class="p">)</span> <span class="p">:::</span> <span class="s">"intel"</span><span class="p">)</span> <span class="p">}</span>
<span class="k">loop</span> <span class="p">{</span>
	<span class="k">let</span> <span class="n">return_address</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="o">*</span><span class="p">(</span><span class="n">base_pointer</span><span class="nf">.offset</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">}</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
	<span class="nd">println!</span><span class="p">(</span><span class="s">"Call site: {}"</span><span class="p">,</span> <span class="n">return_address</span><span class="p">);</span>
	<span class="n">base_pointer</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="n">base_pointer</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">usize</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="isnt-this-an-infinite-loop">Isn’t this an infinite loop?</h3>
<p>That’s right, this loop is going to continue forever, until it hits an
invalid memory address. This is because we don’t know when the stack ends.
There’s a simple solution to this: before we enter the kernel
function, set the return address to zero, and then stop looping when
reaching a return address that is equal to zero.</p>

<p>Here’s the relevant file in exampleOS: <a href="https://github.com/Techno-coder/example_os/blob/15a208f51768b3765154d59225f4a6427a22d0ce/kernel/assembly/boot_entry.asm#L72">boot_entry.asm</a>,
specifically, these two lines:</p>

<pre><code class="language-asm">xor rbp, rbp
push rbp
</code></pre>

<p>We could shorten this down to just <code class="highlighter-rouge">push 0</code> but I believe this code makes the
intent clearer.</p>

<p>Now all we have to do is update our loop:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// ...</span>
<span class="k">while</span> <span class="o">!</span><span class="n">base_pointer</span><span class="nf">.is_null</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Put everything into its own function and then you’re done!</p>

<h2 id="final-thoughts">Final thoughts</h2>
<p>For now, you’ll only see numbers in the stack trace. You can use <code class="highlighter-rouge">objdump</code> to
map these numbers to the assembly code of your kernel. Later on, we’ll be able
to load the kernel symbol table and then print out function names. exampleOS’s
stack trace implementation does this.</p>

<p><a href="/">Back to the root</a></p>

      </section>
    </div>

    
  </body>
</html>
